### Краткий конспект для подготовки к интервью

#### HTTP запросы и протоколы:

**Структура HTTP запроса**

1. Стартовая строка с адресом для запроса, и тип сообщения. Указывается метод, который определяет действия при получении этого сообщения.

2. Заголовки (Headers), в которых прописаны определённые параметры сообщения. Например, может быть напрямую задан язык.

3. Тело запроса (Request Body), текст сообщения — данные, которые передаются. Например, файлы, отправляемые на сервер.

_У HTTP есть расширение — протокол HTTPS. Буква S в аббревиатуре означает Secure._

**Методы HTTP запроса**:

1. _GET_ - для запроса данных с сервера (не содержит тела запроса, но на сервере можно настроить и с телом - но это не валидно с точки зрения REST). Не изменяет данные на сервере, сохраняется историей браузера. **Ограничен 2048 символами** - включая квери параметры. _Кешируется, можно сохранять в закладки, не безопасен для пересылки данных_
   _Неидемпотентный метод_. По умолчанию используется при клике на сабмит формы.

2. _POST_ - отправка данных, создание или обновление ресурса. Данные передаются через тело запроса. Обязателен ответ от сервера - или с сохраненной записью или с ИД или новой ссылкой и т.д. _Неидемпотенттный_ **при отправке множества запросов с одними и теми же данными создаст разный эффект**, т.е. - будут другие ИД у записей в БД или создастся дубликаты и т.д. _Не кешируется, не сохраняется браузером, нет ограничений по длине тела запроса_

3. _PUT_ - создание или обновление ресурса. Отличие от POST - не требует ответа от сервера - полностью перезаписывает данные. _Идемпотентный_ - т.е. **при отправке множества идентичных запросов жедает такой же эффект - как и при отпраке одного**.

4. _PATCH_ - обновление ресурса. Отличие от PUT - **можно обновлять частично**, в зависимости от отправляемых данных. _Идемпотентный_ - задуман _как идемпотентный_, но фактическая реализация может отличаться. На практике _рекомендуется реализовывать запросы PATCH идемпотентным образом_, чтобы обеспечить согласованное поведение на сервере и в БД.

5. _DELETE_ - eудаление ресурса или данных. Тело запроса отсутствует, нужен только идентификатор ресурса.

6. _HEAD_ - идентичен GET запросу, но бех ответа со стороны сервера. Так называемый _Preflight_ запрос - т.е. используется для предзапроса, передавая информацию о предстоящем запросе. Просто возвращает метаданные о ресурсе на сервере. Возвращает все заголовки, связанные с ресурсом по заданному URL, но фактически не возвращает ресурс.
   В основном используется для проверки:

- размера ресурса на сервере;
- существует ли ресурс на сервере;
- дата последнего изменения ресурса;
- срок действия кэшированного ресурса на сервере.

7. _OPTIONS_ - метод HTTP OPTIONS возвращает список поддерживаемых и разрешенных методов, параметры и требования для конкретных ресурсов и возможностей сервера, не предпринимая никаких действий с ресурсом и не запрашивая его. В ответе в хедере Allow могут указываться разрешенные методы HTTP, в заголовках для CORS также разрешенные CORS. По соображениям безопасности, когда отправляем данные на другой домен (междоменные запросы), браузеры обычно отправляют «Preflight» запрос HTTP OPTIONS на сервер перед отправкой туда данных. Не содержит тело запроса, может иметь ответ от сервера. _Безопасный, идемпотентный_

8. _TRACE_ - используется _для диагностики, отладки и устранения неполадок_. Он просто возвращает диагностическую трассировку, в которой регистрируются данные цикла запрос-ответ.Содержимое трассировки часто представляет собой просто ответное эхо от сервера различных заголовков запросов, отправленных клиентом.

9. _CONNECT_ - запускает двустороннюю связь с запрошенным ресурсом . Его можно использовать для открытия туннеля для доступа к сайтам, использующим TLS(HTTPS). Клиент запрашивает прокси-сервер HTTP туннелировать TCP- соединение до желаемого пункта назначения. Затем прокси-сервер устанавливает соединение от имени клиента. После установления соединения прокси-сервер продолжает ретранслировать поток TCP клиенту и обратно. Пошаговый метод, не имеет тела запроса, без ответа, не кешируется, небезопасный, неидемпотентный. Иногда требует специфичных заголовков Proxy-Authorization.

A HEAD request is useful for checking what a GET request will return before actually making a GET request - a HEAD request can read the Content-Length header to check the size of the file, without actually downloading the file

##### Безопасные методы (safe)

- GET, TRACE, HEAD, OPTIONS

##### Небезопасные методы (safe)

- POST, PUT, PATCH, DELETE, CONNECT - _безопасные методы не изменяют данных на сервере_.

#### Идемпотентные методы: множество идентичных запросов дают один и тот же эффект, и при этом сервер будет в одном и том же состоянии.

- GET, PUT, DELETE, TRACE, HEAD, OPTIONS

#### Неидемпотентные методы

- PATCH, POST, CONNECT.

#### Коды ошибок от сервера

- 1xx. Информационные 100 - 199

- 2xx. Успешные 200 - 299

- 3xx. Перенаправления 300 - 399

- 4xx. Клиентские ошибки 400 - 499

- 5xx. Серверные ошибки 500 - 599

**HTTP использует 80 порт по умолчанию, HTTPS 443 порт**

### HTTP vs HTTP2

- **Бинарные данные**

В HTTP данные передаются серверу в формате текста - не производительный вариант.

HTTP/2 использует бинарный формат (машинный код). Данные меньше размером, скорость передачи и парсинга выше. Браузеры с поддержкой HTTP/2 кодируют запросы в бинарный формат перед отправкой, а сервер обрабатывает запрос и декодирует.

- **Мультиплексирование**

Схема работы упрощенно сайта: GET-запрос → возвращает HTML-страницу → подключает доп ресурсы: js, css, картинки, шрифты --> сайт становится интерактивным для пользователя.

В HTTP/1.0 для загрузки каждого ресурса устанавливалось новое TCP/IP соединение. HTTP/1.1 принёс keep-alive, позволил загружать множество ресурсов в рамках одного соединения. Это значительно увеличило производительность протокола. Загрузка ресурса была последовательной (waterfall): нельзя получить следующий ресурс, пока не получен предыдущий. Т.е. зависший запрос блокирует отправку всех остальных.

В HTTP/2 вся информация бьётся на бинарные кусочки — фреймы. Они собираются в потоки - streams, для каждого запрашиваемого ресурса создаётся отдельный stream. Данные передаюся вперемешку в одном TCP/IP соединении. Принимающая сторона самостоятельно соберёт все фреймы из одного потока и обработает их. Клиент теперь может прервать получение одного потока, не закрывая соединение.

- **Сжатие заголовков через HPACK**

Раньше сжатие тела и заголовков происходило на уровне TLS. Это более низкий уровень по отношению к HTTP (микс транспортного уровня и уровня приложения). Он не знает, какой тип данных сжимает, и жмёт все через gzip.

Алгоритм сжатия был подвержен атакам типа CRIME3 и в результате злоумышленники получали авторизационные куки из сжатых заголовков. Поэтому многие сети блокировали сжатие заголовков, чтобы защитить пользователей от атак.

HTTP/2 представили новый алгоритм сжатия заголовков HPACK4. Он не использует DEFLATE и заточен под эффективную защиту от CRIME-атак. С ним новая версия HTTP стала производительнее и безопаснее.

- **Приоритизация потоков**

Управление порядком обработки и передачи потоков данных на одном соединении. Улучшает производительность, управление ресурсами эффективнее, гибкий контроль рендеринг страницы.

При отправке параллельных запросов на сервер клиент может расставить приоритеты ответов. Присваивается каждому потоку вес от 1 до 256. Чем выше вес, тем выше приоритет. Потоки могут быть связаны с ресурсами на сервере: изображениями, CSS-файлами, HTML-страницами и др.

Сервер обрабатывает данные с более высоким приоритетом, даже если это не первый поток, который был отправлен. Клиент может указывать также зависимости между потоками. Тогда сервер создаёт дерево зависимостей, которое определяет порядок получения данных.

- **Server push**

Функция, кот. позволяет серверу начать передачу ресурсов на клиент ещё до запроса.

**Как это работает:**

Клиент отправляет запрос --> GET /index.html. --> cервер определяет, что будет нужно для полной загрузки страницы. Например, CSS, JS и изображения --> сервер создаёт множество потоков данных и начинает отправлять эти ресурсы через Server Push на клиент, даже если он ещё не запросил их --> Клиент получает ресурсы и может начать их загрузку, даже если они не запрошены явно.

Server Push использует механизмы мультиплексирования и приоритизации потоков.
Но Server Push _эффективен, только если сервер точно знает, какие ресурсы нужны для загрузки страницы_. Иначе случится ненужная передача ресурсов и ухудшение производительности.
