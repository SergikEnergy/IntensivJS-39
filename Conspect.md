### Краткий конспект для подготовки к интервью

#### HTTP запросы и протоколы:

<details>
<summary>**Структура HTTP запроса**</summary>

1. Стартовая строка с адресом для запроса, и тип сообщения. Указывается метод, который определяет действия при получении этого сообщения.

2. Заголовки (Headers), в которых прописаны определённые параметры сообщения. Например, может быть напрямую задан язык.

3. Тело запроса (Request Body), текст сообщения — данные, которые передаются. Например, файлы, отправляемые на сервер.

_У HTTP есть расширение — протокол HTTPS. Буква S в аббревиатуре означает Secure._

</details>

<details>
<summary>**Методы HTTP запроса**:</summary>

1. _GET_ - для запроса данных с сервера (не содержит тела запроса, но на сервере можно настроить и с телом - но это не валидно с точки зрения REST). Не изменяет данные на сервере, сохраняется историей браузера. **Ограничен 2048 символами** - включая квери параметры. _Кешируется, можно сохранять в закладки, не безопасен для пересылки данных_
   _Неидемпотентный метод_. По умолчанию используется при клике на сабмит формы.

2. _POST_ - отправка данных, создание или обновление ресурса. Данные передаются через тело запроса. Обязателен ответ от сервера - или с сохраненной записью или с ИД или новой ссылкой и т.д. _Неидемпотенттный_ **при отправке множества запросов с одними и теми же данными создаст разный эффект**, т.е. - будут другие ИД у записей в БД или создастся дубликаты и т.д. _Не кешируется, не сохраняется браузером, нет ограничений по длине тела запроса_

3. _PUT_ - создание или обновление ресурса. Отличие от POST - не требует ответа от сервера - полностью перезаписывает данные. _Идемпотентный_ - т.е. **при отправке множества идентичных запросов жедает такой же эффект - как и при отпраке одного**.

4. _PATCH_ - обновление ресурса. Отличие от PUT - **можно обновлять частично**, в зависимости от отправляемых данных. _Идемпотентный_ - задуман _как идемпотентный_, но фактическая реализация может отличаться. На практике _рекомендуется реализовывать запросы PATCH идемпотентным образом_, чтобы обеспечить согласованное поведение на сервере и в БД.

5. _DELETE_ - eудаление ресурса или данных. Тело запроса отсутствует, нужен только идентификатор ресурса.

6. _HEAD_ - идентичен GET запросу, но бех ответа со стороны сервера. Так называемый _Preflight_ запрос - т.е. используется для предзапроса, передавая информацию о предстоящем запросе. Просто возвращает метаданные о ресурсе на сервере. Возвращает все заголовки, связанные с ресурсом по заданному URL, но фактически не возвращает ресурс.
   В основном используется для проверки:

- размера ресурса на сервере;
- существует ли ресурс на сервере;
- дата последнего изменения ресурса;
- срок действия кэшированного ресурса на сервере.

7. _OPTIONS_ - метод HTTP OPTIONS возвращает список поддерживаемых и разрешенных методов, параметры и требования для конкретных ресурсов и возможностей сервера, не предпринимая никаких действий с ресурсом и не запрашивая его. В ответе в хедере Allow могут указываться разрешенные методы HTTP, в заголовках для CORS также разрешенные CORS. По соображениям безопасности, когда отправляем данные на другой домен (междоменные запросы), браузеры обычно отправляют «Preflight» запрос HTTP OPTIONS на сервер перед отправкой туда данных. Не содержит тело запроса, может иметь ответ от сервера. _Безопасный, идемпотентный_

8. _TRACE_ - используется _для диагностики, отладки и устранения неполадок_. Он просто возвращает диагностическую трассировку, в которой регистрируются данные цикла запрос-ответ.Содержимое трассировки часто представляет собой просто ответное эхо от сервера различных заголовков запросов, отправленных клиентом.

9. _CONNECT_ - запускает двустороннюю связь с запрошенным ресурсом . Его можно использовать для открытия туннеля для доступа к сайтам, использующим TLS(HTTPS). Клиент запрашивает прокси-сервер HTTP туннелировать TCP- соединение до желаемого пункта назначения. Затем прокси-сервер устанавливает соединение от имени клиента. После установления соединения прокси-сервер продолжает ретранслировать поток TCP клиенту и обратно. Пошаговый метод, не имеет тела запроса, без ответа, не кешируется, небезопасный, неидемпотентный. Иногда требует специфичных заголовков Proxy-Authorization.

A HEAD request is useful for checking what a GET request will return before actually making a GET request - a HEAD request can read the Content-Length header to check the size of the file, without actually downloading the file

</details>

##### Безопасные методы (safe)

- GET, TRACE, HEAD, OPTIONS

##### Небезопасные методы (safe)

- POST, PUT, PATCH, DELETE, CONNECT - _безопасные методы не изменяют данных на сервере_.

#### Идемпотентные методы: множество идентичных запросов дают один и тот же эффект, и при этом сервер будет в одном и том же состоянии.

- GET, PUT, DELETE, TRACE, HEAD, OPTIONS

#### Неидемпотентные методы

- PATCH, POST, CONNECT.

<details>
<summary>#### Статус коды ответа от сервера</summary>

- 1xx. Информационные 100 - 199

- 2xx. Успешные 200 - 299

- 3xx. Перенаправления 300 - 399

- 4xx. Клиентские ошибки 400 - 499

- 5xx. Серверные ошибки 500 - 599

</details>

**HTTP использует 80 порт по умолчанию, HTTPS 443 порт, DNS - 53**

### HTTP vs HTTP2

<details>
<summary>- **Бинарные данные**</summary>

В HTTP данные передаются серверу в формате текста - не производительный вариант.

HTTP/2 использует бинарный формат (машинный код). Данные меньше размером, скорость передачи и парсинга выше. Браузеры с поддержкой HTTP/2 кодируют запросы в бинарный формат перед отправкой, а сервер обрабатывает запрос и декодирует.

</details>
<details>
<summary>- **Мультиплексирование**</summary>

Схема работы упрощенно сайта: GET-запрос → возвращает HTML-страницу → подключает доп ресурсы: js, css, картинки, шрифты --> сайт становится интерактивным для пользователя.

В HTTP/1.0 для загрузки каждого ресурса устанавливалось новое TCP/IP соединение. HTTP/1.1 принёс keep-alive, позволил загружать множество ресурсов в рамках одного соединения. Это значительно увеличило производительность протокола. Загрузка ресурса была последовательной (waterfall): нельзя получить следующий ресурс, пока не получен предыдущий. Т.е. зависший запрос блокирует отправку всех остальных.

В HTTP/2 вся информация бьётся на бинарные кусочки — фреймы. Они собираются в потоки - streams, для каждого запрашиваемого ресурса создаётся отдельный stream. Данные передаюся вперемешку в одном TCP/IP соединении. Принимающая сторона самостоятельно соберёт все фреймы из одного потока и обработает их. Клиент теперь может прервать получение одного потока, не закрывая соединение.

</details>

<details>
<summary>- **Сжатие заголовков через HPACK**</summary>

Раньше сжатие тела и заголовков происходило на уровне TLS. Это более низкий уровень по отношению к HTTP (микс транспортного уровня и уровня приложения). Он не знает, какой тип данных сжимает, и жмёт все через gzip.

Алгоритм сжатия был подвержен атакам типа CRIME3 и в результате злоумышленники получали авторизационные куки из сжатых заголовков. Поэтому многие сети блокировали сжатие заголовков, чтобы защитить пользователей от атак.

HTTP/2 представили новый алгоритм сжатия заголовков HPACK4. Он не использует DEFLATE и заточен под эффективную защиту от CRIME-атак. С ним новая версия HTTP стала производительнее и безопаснее.

</details>
<details>
<summary>- **Приоритизация потоков**</summary>

Управление порядком обработки и передачи потоков данных на одном соединении. Улучшает производительность, управление ресурсами эффективнее, гибкий контроль рендеринг страницы.

При отправке параллельных запросов на сервер клиент может расставить приоритеты ответов. Присваивается каждому потоку вес от 1 до 256. Чем выше вес, тем выше приоритет. Потоки могут быть связаны с ресурсами на сервере: изображениями, CSS-файлами, HTML-страницами и др.

Сервер обрабатывает данные с более высоким приоритетом, даже если это не первый поток, который был отправлен. Клиент может указывать также зависимости между потоками. Тогда сервер создаёт дерево зависимостей, которое определяет порядок получения данных.

</details>

- **Server push**

Функция, кот. позволяет серверу начать передачу ресурсов на клиент ещё до запроса.

<details>
<summary>**Как это работает:**</summary>

Клиент отправляет запрос --> GET /index.html. --> cервер определяет, что будет нужно для полной загрузки страницы. Например, CSS, JS и изображения --> сервер создаёт множество потоков данных и начинает отправлять эти ресурсы через Server Push на клиент, даже если он ещё не запросил их --> Клиент получает ресурсы и может начать их загрузку, даже если они не запрошены явно.

Server Push использует механизмы мультиплексирования и приоритизации потоков.
Но Server Push _эффективен, только если сервер точно знает, какие ресурсы нужны для загрузки страницы_. Иначе случится ненужная передача ресурсов и ухудшение производительности.

</details>
### HTTPv.3 - ключевые особенности

HTTP2 использует TCP (или TLS - for secure), HTTP3 - транспортный протокол под названием QUIC - отличается от TCP по ключевым пунктам, поэтому использовать поверх него HTTP/2 очень сложно.
Поэтому HTTP/3 — изменение HTTP/2 для адаптации к новому протоколу QUIC.
**_Расшифровка_ Quick UDP Internet Connections**

1. **TCP**
   1.1 _TCP требует рукопожатие для установки нового соеинения (handshake), для проверки, что клиент и сервер существуют и готовы обмениваться данными. Если клиент и сервер находятся далеко, время кругового пути - затраченное на отправку синрала и получения отчета о его доставке (round-trip time, RTT) может составить более 100 мс, что приводит к ощутимым задержкам._
   1.2 _TCP_ передает все, как один «файл», даже для нескольких файлов одновременно (например, загружаем страницу с несколькими ресурсами). Т.е. это задержки при передаче в случае сбоя в очереди (head-of-line (HoL) blocking).

**по факту поэтому HTTP/3 могли назвать _HTTP/2-over-QUIC_**

2. **QUIC** _находится поверх UDP протокола транспортного уровня_
   2.1 это универсальный транспортный протокол. QUIC работает поверх ещё одного протокола — UDP (_отличие от TCP в параллельной загрузке данных и из неблокировании, даже если они потерялись, удобно для видео хостингов - не важно с какого места начать передачу и т.д._). QUIC может быть и отдельным протоколом, но тогда, как и для обновления _TCP_: нудно обновить все устройства в интернете для работы с QUIC. Поэтому его разместили поверх UDP.
   2.2 использует подтверждение полученных пакетов и повторные передачи, чтобы добрать то, что потерялось - т.е. _блокирует не всю передачу данных - а только тот поток, где потерялись - потом их дошлет_.
   2.3 QUIC глубоко интегрирован с TLS - т.е. работает только с TLS, поддерживает несколько независимых потоков байтов, использует идентификаторы соединений, использует фреймы.
   **Т.е. HTTP3 по умолчанию зашифрован**
   2.4 Поддерживает миграцию соединений - т.е. соединения могут дольше оставаться активными. QUIC вводит новую концепцию — **идентификатор соединения CID**. Каждому соединению между двумя конечными точками помимо четырёх параметров (ранее в _TCP_ это были _IP-адрес клиента_ + _порт клиента_ + -IP-адрес сервера* + *порт сервера\*) присваивается уникальный номер. Поскольку **CID** определяется на транспортном уровне в самом QUIC.
   Ранее при перемещении между сетями - в TCP - перезапускалось соединение при перемещении сервера или клиента (изменении одного из 4-х указанных параметров). QUIC меняет CID при каждом переходе в новую сеть - для избежания хакерских атак. Но клиент и сервер "знают" общий список рандомно генерируемых CID, которые связаны с одним и тем же соединением - поэтому соединение не переустанавливается (сервер и клиент сверяют доступные CID).
   2.5 Гибкость и простота развития QUIC - занимает переход на него и развитие меньше времени.

3. - **Сжатие заголовков через QPACK**

4. Более быстрое установление соединения - _из-за сокращенного механизма рукопожатий_ теперь шифрование части ключа уже происходит на сервере и клиенте. За счет этого проходит сразу обмен данными, т.е. нулевое время прохождения туда и обратно (0-RTT).
5. Контроль и восстановление перегрузок

6. HTTP/3 имеет более высокую пропускную способность - из-за мультиплексирования запросов по одному соединению.

### Способы отмены запроса

##### Abort Controller - для fetch больше всего делается

- для таких целей существует специальный встроенный объект: AbortController, для отмены не только fetch, но и других асинхронных задач:

1. - создаем объект

```javascript
const controller = new AbortController();
```

Экземпляр имеет единственный метод abort() и единственное свойство signal.
_При вызове abort():_ генерируется событие с именем abort на объекте controller.signal
_свойство controller.signal.aborted становится равным true_ 2. Чтобы узнать о вызове abort(), ставим обработчики на controller.signal, чтобы отслеживать его.

```javascript
const controller = new AbortController();
const signal = controller.signal;

signal.addEventListener('abort', callback);
```

3. Вызываем метод _abort()_ - где необходимо

```javascript
const controller = new AbortController();
const signal = controller.signal;

signal.addEventListener('abort', callback);

controller.abort(); //здесь выполнится callback
```

4. Для fetch-запроса из браузерного API есть доп. опция signal? рядом с хедером и т.д.

```javascript
const controller = new AbortController();
fetch(url, {
  signal: controller.signal,
});
```

5. Вызываем событие и fetch отменится - и промис завершится с ошибкой - которую надо отловить

```javascript
controller.abort();
```

**AbortController** масштабируемый - т.е. может отменить несколько фетч запросов сразу

```javascript
const urls = ['url/1','url/2'...];

const controller = new AbortController();

const fetchList = urls.map(url => fetch(url, {
  signal: controller.signal
}));

const results = await Promise.all(fetchJobs);

// вызов controller.abort() прервёт все вызовы fetch сразу и завершит ошибкой
// обработка ошибки от вызова abort()
catch(err) {
  if (err.name == 'AbortError') {
    errorCallback();
  } else {
    throw err;
  }
}
```

**соответственно, если надо управлять гибко отменой - надо создать несколько объектов abortController**

##### `abort()` в объекте запроса - для старого XMLHttpRequest.

##### Промисы и async/await:

При использовании промисов или async/await, можно использовать Promise.race, чтобы создать гонку между промисом запроса и промисом отмены. Как только промис отмены выполнится первым, вы сможете обработать отмену запроса.

```javascript

```

##### Использование Axios (или других HTTP клиентов):

- Некоторые HTTP клиенты, такие как Axios, предоставляют встроенные методы для отмены запросов.

```javascript
import axios from 'axios';

const cancelTokenController = axios.CancelToken.source();

axios
  .get('https://api.example.com/data', { cancelToken: cancelTokenController.token })
  .then((response) => {
    console.log(response.data);
  })
  .catch((error) => {
    if (axios.isCancel(error)) {
      console.log('Request cancelled:', error.message);
    } else {
      console.log('Error:', error.message);
    }
  });

cancelTokenController.cancel('Request cancelled manually'); //cancel event
```

### Объекты в JS

<details>
<summary>Методы объектов</summary>

- **Создание объектов**

```javascript
const obj = {}; // литеральная запись - прямое создание
const obj2 = new Obj(); // с помощью конструктора
/*
Несмотря на то, что obj и obj2 неизменные, свойства объекта можно менять, т.к. объект хранится по ссылке. Изменение внутреннего состояния не изменяет ссылку.
Но нельзя перезаписать объект obj2='other type' //TypeError: Assignment to constant variable
*/
function FuncConstructor(prop1, prop2) {
  //функция-конструктор
  this.key1 = prop1;
  this.key2 = prop2;
}
/* is the same as implicitly {
	const this={};
	{body function}
	return this;
}*/
// обязательно вызывать только с new - если вызвать без new - просто вернет undefined;
class ObjCreator {
  constructor(prop1, prop2) {
    this.key1 = prop1;
    this.key2 = prop2;
  }
  //come methods
  sayHi() {
    return `Hi user ${this.key1}`;
  }
}
//современный синтаксис - класс вместо функции конструктора
// в данном случае вернет при вызове без new - TypeError - нельзя вызывать класс без new!!!

//Использование метода Object.create
const newObj = Object.create(prototype, props); //мы можем передать прототип - т.е. тот объект, от которого наследуемся - и таким образом мы получим доступ к его свойствам
//props - это обязательно объект с ключами и значениями

const newObj = Object.create({}, { user: 'user' }); //к пустому объекту добавим св-во user

//можно добавлять дескрипторы свойств
const newObj = Object.create({}, { name: { value: 'user', enumarable: false, writable: true, configurable: false } });
//или включать геттеры и сеттеры
const newObj = Object.create(
  {},
  {
    name: {
      value: '',
      enumarable: false,
      writable: true,
      configurable: false,
      get: function () {},
      set: function () {},
    },
  }
);

//через Object.defineProperty(); || Object.defineProperties();
const obj1=Object.defineProperty({}, 'user', {get:, set:, descriptors: writanle,enumarable,configurable});
```

- удаление свойств: - удаляет свойство объекта - при образении к такому св-ву вернется undefined - как и у любошо несуществующего св-ва

- более структурно см. (Дескрипторы на learnJS)[https://learn.javascript.ru/descriptors-getters-setters]

```javascript
delete object.someProperty;
delete object['property'];
```

- новый синтаксис объявления свойств (_касаемо методов_):

```javascript
const obj = {
  name: 'defaultName',
  sayHi: function () {
    console.log('hi');
  },
}; // old
const objNew = {
  name: 'defaultName',
  sayHi() {
    console.log('hi');
  },
}; //new
//when we have variables
const name = 'name';
const lastName = 'lastName';
const objShort = {
  name,
  lastName,
};
//the same as {name: name, lastName:lastName};
```

- обращение к св-ву объекта через `. obj.prop` или через квадратные скобки - удобно для переменных или составных свойств (типа класса в ДОМ узлах) `obj[property] или obj['complete__className-prop']`

- _ограничения_ - ключи - только строки или символы, значения - любой тип данных;

</details>

<details>
<summary>Копирование объектов в JS</summary>

1. `Object.assign(target, source1,...,sourceN)`;
   где target - целевой объект - source - объект(ы) из которого копируются свойства.
   - копирует _только перечисляемые и собственные свойства_ _из исходного_ объекта _в целевой_ объект. Он использует [[Get]]-источник и [[Set]]-цель, поэтому будет вызывать геттеры и сеттеры . В итоге метод _просто присваивает_ свойства, а _не копирует или определяет новые_.
     Для копирования определений свойств (включая их перечисляемость) в прототипы надо использовать `Object.getOwnPropertyDescriptor()` - **возвращает объект со всеми флагами и дескрипторами указанного свойства объекта** - в и `Object.defineProperty()` - для переопределнеия свойства с его конфигурацией.
     **осуществляет только поверхностное копирование**
2. _spread_ - оператор
   `const obj={...source}` - _только поверхностное копирование_

3. сторонние библиотеки - (`cloneDeep from lodash`) - полное копирование объекта

4. `JSON.parse(JSON.stringify(obj))` - _полное копирование_ - но некорректно копирует методы, массивы
   Не обрабатывает _несериализуемых данные_: примитив undefined, функция, symbol - при вызове JSON.stringify получаем undefined.

- если такие параметры будут в массиве, то такие значения будут превращены в null;
- если в объекте: такие значения будут опущены, а symbol если он является ключом объекта будет проигнорирован.
</details>

5. Собственная функция копирования с рекурсивным обходом всех ключей

#### Функция structuredClone()

<details>
<summary>Глубокое копирование объектов в JS</summary>

`structuredClone` является встроенным методом, который позволяет создавать глубокую копию объекта или сложной структуры данных - т.е. объекта window или global nodeJS. Предоставляется `Web API` в современных браузерах. Рекурсивно клонирует свойства и вложенные объекты.

**Пример**

```javascript
const originalObject = {
  name: 'John',
  age: 30,
  addresses: [{ street: '123 Main St', city: 'New York' }],
};

const clonedObject = window.structuredClone(originalObject) || structuredClone(originalObject);
```

**Ограничения**

- Функции и методы не клонируются;

- некоторые свойства, как символы или свойства с круговыми ссылками, не могут быть сериализованы и исключаются во время процесса клонирования. Полученная копия не будет содержать эти свойства.

- Узлы DOM и сложные встроенные объекты: File или Blob.

Для большей инфорации см. (Доку от MDN)[https://developer.mozilla.org/en-US/docs/Web/API/structuredClone]

</details>

### Функции и контекст выполнения

Сущуствует три вида контекста выполнения:

- Глобальный контекст - существует всегда - неможет быть больше одного такого контекста;
- Контекст выполнения функции - создается в момент вызова какой-то функции - для каждой функции свой контекст выполнения;
- Котекст выполнения функции _eval_ - деприкейтел в JS - из-за уязвимости.

**JS хранит и отслеживает контексты в стеке вызовов - _call stack_** - LIFO - структура (последний пришел, первый вышел) - после выполнения функции ее контекст удаляется - и переходим к контексту, находящемуся под ней.

_Создание контекста выполнения_

- Определяется this и осуществляется привязка this (this binding);
- Создаётся компонент LexicalEnvironment;
- Создаётся компонент VariableEnvironment;
  Условно 'под капотом'

```javascript
ExecutionContext={
	ThisBinding=<this value>,
	LexicalEnvironment={...},
	VariableEnvironment={...},
}
```

**Способы привязки контекста**

1. привязка через new

```javascript
function Foo(a){
	this.a=a;
}

var foo=new Foo(4);
foo.a=? //4
```

2. явная привязка (call, apply, bind)

```javascript
function foo(a){
	console.log(this.a);
}
const obj2={a:6};


foo.call(obj2, a)=? //6 - obj2 - указываем, какой контекст привязывать для foo, след.аргумент - переменная
//call, apply - сразу же вызывают функцию с указанными аргументами, bind - только привязывает контекст и устанавливает аргументы для функции, но не вызывает ее
```

3. неявная привязка

```javascript
function foo(a){
	console.log(this.a);
}
const obj2={a:2, foo: foo};


obj2.foo()=? //2  - в данном случае контекст - это объект до точки.
```

4. неявная привязка

```javascript
function foo(a){
	console.log(this.a);
}
var a=2;


foo()=? //2  - в данном случае контекст - зависит от окружения функции - и берется из вне - т.е., для глобальной функции - это window - браузер, global - node, 'use srtict' - undefined.
```

**Приоритет привязок - именно такой, как и указано в номерах привязок - и перебить их нельзя - т.е. привязка работает _только один раз_**

- иными словами **Один раз привязанный контекст не может быть “перепривязан” снова.**

- _call_ vs _apply_ - различие только в том, что apply принимает аргументы в виде массива, call - через запятую в виде последоваьельности `call(ctx, arg1,arg2,...,argN)` `apply(ctx, [arg1,arg2,...,argN])`

<details>
<summary>Коньекст вызова стрелочной функции</summary>

- Особенности стрелочной функции

1. синтаксис - более сокращенный

```javascript
const foo = (arg) => {
  //body
  return smth;
};
// сокращенно если нет тела функции
const foo = (arg1, arg2) => smth;
// если только один аргумент, то еще проще (скобки опускаются)
// const foo = arg2 => smth; - но рекомендуется все равно оборачивать - для большей читаемости кода
```

2. нет своего контекста this - т.е. контекст берется из контекста родителя в момент определения функции
3. нет псевдомассива arguments
4. не может быть конструктором (нельзя вызвать с new, нет метода super)

**Стрелочные функции всегда используют this окружающего контекста!**

</details>

#### Структуры данных в JS

1. Массивы

_Массивы в JS являются “неправильными”_ - это спископодобные объекты, чьи прототипы содержат методы для операций обхода и изменения массива.

- совмещают в себе функции сразу нескольких структур данных - не так как в других языках программирования.
**упорядоченные списки** - каждый элемент имеет свой индекс и доступ к нему по индексу
**объекты** - массивы имеют свои свойства, как и у объекта - типа length, можно задавать массиву свои свойства
<details>
<summary>Контекст вызова стрелочной функции</summary>

```javascript
const arr = ['a', 'b', 'c'];
arr.prop1 = 'value1'; // валидно 0 но свойство не доступно в цикле for .. of .. - только для fot .. in..

for (const key in arr) {
  console.log(key);
  console.log(arr[key]);
}

for (const digit of arr) {
  console.log(digit);
}
```

**Динамические массивы:** В JS массивы могут изменять размер во время выполнения программы, добавляя новые элементы или удаляя существующие. _Ни размер JS-массива, ни типы его элементов_ **не являются фиксированными**. Размер массива может увеличиваться и уменьшаться в любое время, то нет гарантии, что массив окажется _плотным (т.е. заполненным полностью - **в отличие от разряженного**)_.

В других языках программирования длина массива должна быть неизменной. Для того, чтобы добавить элемент в массив, нужно создать новый массив длиннее старого на 1 элемент, затем скопировать в него все значения старого массива и в качестве последнего элемента указать новое значение.
**Ассоциативные массивы:** В JS массивы могут быть _ассоциативными_, где в качестве индексов могут использоваться не только числа, но и строки или символы. Это позволяет создавать массивы, в которых каждому элементу присваивается уникальный ключ.
`const arr=[['key1','value1'],['key2','value2'],...,['keyN', 'valueN']]`
_но лучше для этого использовать специальные типы данных_ - объекты, Мар.

- массив может содержать ращличные типы данных - как примитивы, так и другие объекты, массивы.

</details>

#### Алгоритмы сортировок

1. Сортировка пузырьком - неоднократно сравнивает соседние элементы и меняет их местами, если они расположены в неправильном порядке. Перебор идет до тех пор, пока замены больше не понадобятся. Сложность алгоритма O(n^2) в среднем и худшем случаях;

<details>
<summary>Пример кода JS</summary>

```javascript
function sortBubble(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr.length; j++) {
      if (arr[j + 1] < arr[j]) {
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }
  }
  return arr;
}
```

</details>

2. Сортировка выбором - на каждой итерации выбирается самый маленький элемент (или самый большой) из несортированной области и перемещается в конец сортированной. во всех случаях имеет сложность O(n^2)

<details>
<summary>Пример кода JS</summary>

```javascript
function sortSelection(arr) {
  for (let i = 0; i < arr.length; i++) {
    const min = i;
    for (let j = i; j < arr.length; j++) {
      if (arr[j] < arr[min]) {
        min = j;
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
  return arr;
}
```

</details>

3. Циклическая сортировка - основная идея алгоритма - разложение массива на циклы. Внутри этих циклов происходят перестановки элементов до тех пор, пока все циклы не завершатся и массив не будет отсортирован. Сложность O(n^2).
   Является _нестабильным алгоритмом_ - _не гарантирует сохранение относительного порядка элементов с одинаковыми ключами при сортировке_. Т.е., если в исходном массиве есть два элемента с одинаковыми ключами, то после сортировки они могут поменяться местами.

4. Быстрая сортировка;

<details>
<summary>Пример кода JS</summary>

```javascript
function sortSelection(arr) {
  for (let i = 0; i < arr.length; i++) {
    const min = i;
    for (let j = i; j < arr.length; j++) {
      if (arr[j] < arr[min]) {
        min = j;
      }
    }
    [arr[i], arr[min]] = [arr[min], arr[i]];
  }
  return arr;
}
```

</details>;

### Принципы написания кода

1. DRY — Don't Repeat Yourself (или DIE — Duplication Is Evil) -

- не повторяться при написании кода. Все, что есть в проекте, д. б. определено один раз, чтобы избежать потом правок в несколько повторяющихся фрагментов кода вместо одного, также дублированный код приводит к накоплению нежелательного кода и затрудняет его понимание и чтение;

**Примеры**

<details>
<summary>группировка CSS селекторов</summary>

```javascript
h1 {
  color: #ff0000;
  font-family: Arial;
}
h2 {
  color: #ff0000;
  font-family: Arial;
}
h3 {
  color: #ff0000;
  font-family: Arial;
}
h4 {
  color: #ff0000;
  font-family: Arial;
}
//WRONG
We can use h1,h2,h3,h4{
	color: #ff0000;
  font-family: Arial;
}
```

</details>;

<details>
<summary>циклы</summary>

```javascript
// non DRY code
console.log('corn');
console.log('pita');
console.log('potato');
console.log('tortilla');
// WRONG

const chips = ['corn', 'pita', 'potato', 'tortilla'];

for (let i = 0; i < chips.length; i++) {
  console.log(chips[i]);
}
// RIGHT
```

</details>;

2. KISS — keep it short simple / keep it simple, stupid

- чем проще код, тем легче его понять всем людям, занимающимся его поддержкой. Простота означает отказ от использования сложных шаблонов и ненужных усложнений.;

3.  YAGNI — You ain't gonna need it

- все, что не требуется для того, чтобы проект работал так, как запланировано, в нем быть не должно. Или _не стоит писать функционал на будущее, если он не нужен прямо сейчас_.

4. Комментарии - используй комментарии - там, где необходимо оюъяснить код - но только в исключительных случаях - осмысленные имена функций, переменных - помогут избежать написания комментариев, т.к. должны быть самоговорящими о действии той или иной функции.

4.1 TODO - использовать в коде удобно для пометки запланированной задачи, фичи на будущее.

```javascript
// TODO: move this to the configuration file...
//example
```

#### Антипаттерны чистого кода

1. _Преждевременная оптимизация_

- примеры: кэширование до того, как провели профилирование, использование сложных и недосказанных правил вместо алгоритмов, работа с новыми, непротестированными фреймворками, библиотеками, которые могут повести себя плохо под нагрузкой в будущем.
- **как избежать**: сначала писать чистый, читаемый, работающий код, используя известные и проверенные алгоритмы и инструменты.

2. _Спагетти-код_

- код с практически нулевой структурой, ничего не модулируется. файлы случайным образом разбросаны по случайным каталогам, ход программы трудно проследить.

3. _Золотой молот_ - применение везде и во всем одного и того же функционала, паттерна, программы.

- везде применять знакомый и любимый архитектурный подход, Например, даже если писать кож надо в два раза дольше, а программа в итоге станет менее производительной, но это же работает - зачем менять то что работает.

**Как избежать** постоянная учеба на протяжении всей карьеры, выбирать наиболее подходящий язык для проекта. Продумывать архитектуру и выходить за рамки обыденного, пробовать в работе новые инструменты и новые способы решения проблем.

4. _Лодочный якорь_ - оставлять неиспользуемый код в базе, вдруг он понадобиться позже.

Лишний или устаревший код увеличивает время сборки, можно перепутать рабочий и нерабочий код, нечаянно добавив последний в продакшн.

5. _Мертвый код_ - чаще всего этот антипаттерн встречается в коде, который написали для проверки концепции, а затем запустили в производство. Этот код вреден, потому что нельзя определить, нужен ли он для работы программы, или нет.

6. _Разрастание кода_ - предполагает наличие в кодовой базе объектов, которые существуют исключительно для вызова других, более важных объектов. Это добавляет ненужный уровень абстракции и сбивает с толку, когда необходимо разобраться в работе программы. _Лучшее решение_ — просто удалить лишний объект. Переместите ответственность за вызов необходимого объекта на вызывающий объект.

7. _Божественный объект_ или _швейцарский нож_ - такие объекты делают слишком много. Могут и отвечать за идентификатор пользователя, идентификатор транзакции, имя и фамилию клиента, общую сумму транзакции, товары, которые покупает пользователь…

_Решение_ разделять такие объекты на отдельные модули. - аналог _single responsibility_ в SOLID.

#### Способы хранения информации

1. LocalStorage, SessionStorage - объекты веб-хранилища, которые врщволяюь хранить пары ключ/значение в браузере.

- объекты веб-хранилища не отправляются на сервер при каждом запросе.
- поэтому можно хранить гораздо больше данных (как минимум до5 МБ и этот размер можно поменять в настройках браузера)
- сервер не может манипулировать объектами хранилища через HTTP-заголовки, только при помощи JavaScript.
- хранилище привязано к источнику (домен/протокол/порт). Т.е. разные протоколы или поддомены определяют разные объекты хранилища, и они не могут получить доступ к данным друг друга.
- объект localStorage доступен всем окнам из одного источника, если мы устанавливаем данные в одном окне, изменения становятся видимыми в другом.
- объекты веб-хранилища нельзя перебрать в цикле, они не итерируемы, но можно пройти по ним, как по обычным массивам.

```javascript
for (let i = 0; i < localStorage.length; i++) {
  console.log(localStorage.key(i));
}
```

**Методы**:

- `setItem(key, value)` – сохранить пару ключ/значение.
- `getItem(key)` – получить данные по ключу key.
- `removeItem(key)` – удалить данные с ключом key.
- `clear()`– удалить всё.
- `key(index)` – получить ключ на заданной позиции.
- `length` – количество элементов в хранилище.
  **Также можно получать удалять данные как в обычном объекте**:

2. SessionStorage vs LocalStorage

2.1. sessionStorage существует только в рамках текущей вкладки браузера.
2.2. Другая вкладка с той же страницей будет иметь другое хранилище (sessionStorage привязан не только к источнику, но и к вкладке браузера).
2.3. Данные продолжают существовать после перезагрузки страницы, но не после закрытия/открытия вкладки (в localStorage даже после перезагрузки браузера).

- методы такие же как и у localStorage

- При обновлении данных в localStorage или sessionStorage, генерируется событие **storage**:

- key – ключ, который обновился (null, если вызван .clear()).
- oldValue – старое значение (null, если ключ добавлен впервые).
- newValue – новое значение (null, если ключ был удалён).
- url – url документа, где произошло обновление.
- storageArea – объект localStorage или sessionStorage, где произошло обновление.

**событие срабатывает на всех остальных объектах window**, _где доступно хранилище_, _кроме окна_, _которое его вызвало_.

3. Cookie - это небольшие строки данных, которые хранятся непосредственно в браузере. Они являются частью HTTP-протокола.

- _Куки обычно устанавливаются веб-сервером_ при помощи заголовка **Set-Cookie**. Затем _браузер автоматически добавляет их_ в (почти) каждый запрос на тот же домен при помощи заголовка Cookie.

- значение _document.cookie_ (где можно прочитать куки) состоит из пар **ключ=значение**, _разделённых ;_. Каждая пара представляет собой отдельное куки. Чтобы найти куки, надо сначала разбить строку из document.cookie по ";".

- запись в _document.cookie_ обновит только упомянутые в ней куки, но при этом не затронет все остальные.

```javascript
document.cookie = 'user=Ivan';
//только обновит куки с ключом user - все остальные не перезатрутся

document.cookie = encodeURIComponent(key) + '=' + encodeURIComponent(value);

// Для сложных ключей-значений надо использовать встроенную функцию _encodeURIComponent_
```

- _ограничения для куки:_

1. после `encodeURIComponent` пара `name=value` не должна занимать более 4Кб.

2. общее количество куки на один домен ограничивается примерно 20+ (зависит от браузера).

3. У куки есть ряд настроек, указываются после пары ключ=значение и отделены друг от друга разделителем ;
   `user=Ivan; path=/; expires=Data ...`
   Примеры:

- _path=/mypath_ - URL-префикс пути, куки будут доступны для страниц под этим путём. **Должен быть абсолютным**. По умолчанию используется текущий путь.
- _domain=sample.com_ - домен определяет, где доступен файл куки. **Нельзя указать здесь какой угодно домен**.
  Также **нет способа разрешить доступ к файлам куки из другого домена**, поэтому other.com никогда не получит куки, установленный по адресу sample.com.
  - по умолчанию куки доступны лишь тому домену, который его установил.
  - по умолчанию файл куки также не передаётся поддомену, например forum.sample.com (но если установить явно domain=sample.com - то тогда поддомены тоже увидят изменения).
- _expires, max-age_ - по умолчанию, если куки не имеют ни одного из этих параметров, то они удалятся при закрытии браузера - т.н. _сессионные («session cookies»)_. Дата должна быть точно в этом формате `Tue, 19 Jan 2024 00:12:07 GMT`, во временной зоне GMT. `date.toUTCString` поможет установить правильную дату.
  `max-age=3600` - продляет время жизни на количество секунд, указанных в параметре.
- _samesite_ предоставляет ещё один способ защиты от CSRF(cross-site-request-forgery) (первый способ - это наличие специального токена в обзении с сервером).
  Куки с _samesite=strict_ или просто _samesite_ никогда не отправятся, даже если пользователь пришёл не с этого же сайта
- _httpOnly_ - запрещает воздействие на куки с помощью JS

### IndexedDB

Это встроенная база данных, более мощная, чем localStorage.

- хранит практически любые значения по ключам, несколько типов ключей
- поддерживает транзакции для надёжности.
- поддерживает запросы в диапазоне ключей и индексы.
- позволяет хранить больше данных, чем localStorage. Интерфейс для IndexedDB, основан на событиях. (есть вариант async/await на промисах)
- Ключ должен быть одним из следующих типов: number, date, string, binary или array.
- Все операции с данными в IndexedDB могут быть сделаны только внутри транзакций - (транзакция - это группа операций, которая или не выполняется вся или вся выполняется).

### Парадигмы программирования

1. Функциональное программирование (ФП)
   1.1 концепции ФП:

- чистые функции (при вызове функции с одними и теми же значениями получается один и тот же результат, т.е. не содержит сайд эффектов).

- декларативность (есть 2 стиля написания **императивный** - подробно и по шагам - по деталям получить желаемый результат - использовать нативные функции для получения резльтата, т.е. _мы пишем инструкцию компьютеру_, **как он должен работать**, **декларативный** - позволяет вам получить необходимый результат, не углубляясь в детали используемых функций, можно использовать уже встроенные функции и т.д., т.е. мы говорим **что сделать**, а не _как это сделать_).

- иммутабельность (подразумевается, что все данные неизменяемы - поэтому нужно или всегда создавать копию данных внутри функции - чтобы был более структурированный подход).

- функции первого порядка, высшего порядка.

Примеры:
**Композиция**

//TODO - complete function compose, carry ...

### Веса селекторов

- _Специфичность_ — это алгоритм, благодаря которому браузер определяет, какие именно стили из всего набора применить к элементу. В вычислениях участвуют CSS-селекторы. Если одному и тому же элементу подходит сразу несколько CSS-правил с разными селекторами, то браузер применяет те стили, вес селектора которых больше.
  **Правило каскада «кто ниже, тот и выигрывает» при этом может нарушаться**

_По убыванию специфичности_:

- Селекторы по _идентификатору_; - (1)
- Селекторы по _классу_, селекторы _по атрибуту_ и селекторы с _псевдоклассами_; - (2)
- Селекторы по _тегу_, _селекторы с псевдоэлементами_ - (3).

- _Комбинаторы_ **+, >, ~**, универсальный селектор **\*** и псевдокласс **:where()** **веса не имеют**.
- псевдоклассы **:is(), :has() и :not()** принимают вес _наиболее специфичного селектора_ внутри скобок.

**Пример расчета:**
Изначально представляем любой селектор в виде трёх нулей: _(0.0.0)_.
(1) увеличивает первую цифру
(2) увеличивает вторую цифру
(3) - третью.

- _div#some_ состоит из одного селектора по тегу и одного идентификатора. Итоговый вес селектора 1.0.1.
- _section h1_ - получаем вес 0.0.2.
- _#block section > .list a_ - получаем вес (1.1.2).

**Атрибут style**
CSS-свойства, написанные в атрибуте style внутри HTML-разметки, **перебивают свойства**, написанные для этого элемента во внешних CSS-файлах или внутри тега <style>. _Атрибут_ style самый специфичный, у него самый большой вес.

**!important**
Ключевое слово _!important_ насильно применяет свойство, после которого написано. _!important_ всегда стоит использовать с осторожностью и не злоупотреблять им. В том числе из-за того, что оно нарушает естественную работу специфичности и каскада.
**Чтобы перебить !important** нужно использовать более специфичные селекторы с этим же !important.

### use strict - ограничения

_объявляется вначале функции либо модуля - тогда весь файл(модуль) или тело функции будет в use strict_

1. В общем

- Выбрасывает ошибки, когда в коде используются некоторые небезопасные конструкции.
- Выключает функции языка, которые запутывают код и потому не должны использоваться.
- Предотвращает использование слов, которые могут быть использованы в качестве ключевых в будущем.

2. Детально

- Интерпретатор в строгом режиме выбросит ошибку, если обратиться к переменной без её объявления:

```javascript
'use strict';

age = 24;
console.log(age);
// Uncaught ReferenceError: age is not defined
```

т.е. - нельзя неявно добавить глобальную переменную

- С помощью Object.defineProperty() или Object.preventExtensions() можно запретить перезаписывать поля объекта. При включённом строгом режиме попытка перезаписать поле приведёт к ошибке -

```javascript
'use strict';

const obj = {};

Object.defineProperty(obj, 'someProp', { value: 'Alex', writable: false });

obj.someProp = 'other'; // Uncaught TypeError: Cannot assign to read only property 'someProp' of object #<Object>.
```

тоже самое и для попытки удалить, добавить свойство при configurable:false

- параметры функции не могут иметь одинаковые имена `func(a,b,a)`- Uncaught SyntaxError: Duplicate parameter name not allowed in this context (без use strict код выполнится, но обратиться к переопределённому параметру невозможно (т.е. выведется перезаписанное значение)). тоже самое со свойствами серриализуемых объектов - одинаковые нельзя создавать - ошибка

- this не ссылается по умолчанию на глобальный объект - будет undefined;
- запрещено использовать зарезервированные слова;
- дополнительно строгий режим не позволяет использовать в коде конструкцию with и очищает переменные, созданные с помощью eval()
- в модулях и классах use strict - default=on;
- запрещает установку свойств primitive-значениям. Без строгого режима, установка свойств просто игнорируется (т.е. работает auto-boxing and unboxing), со строгим режимом, однако, выдаёт TypeError.
-
