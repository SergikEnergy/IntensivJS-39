### Краткий конспект для подготовки к интервью

#### HTTP запросы и протоколы:

<details>
<summary>**Структура HTTP запроса**</summary>

1. Стартовая строка с адресом для запроса, и тип сообщения. Указывается метод, который определяет действия при получении этого сообщения.

2. Заголовки (Headers), в которых прописаны определённые параметры сообщения. Например, может быть напрямую задан язык.

3. Тело запроса (Request Body), текст сообщения — данные, которые передаются. Например, файлы, отправляемые на сервер.

_У HTTP есть расширение — протокол HTTPS. Буква S в аббревиатуре означает Secure._

</details>

<details>
<summary>**Методы HTTP запроса**:</summary>

1. _GET_ - для запроса данных с сервера (не содержит тела запроса, но на сервере можно настроить и с телом - но это не валидно с точки зрения REST). Не изменяет данные на сервере, сохраняется историей браузера. **Ограничен 2048 символами** - включая квери параметры. _Кешируется, можно сохранять в закладки, не безопасен для пересылки данных_
   _Неидемпотентный метод_. По умолчанию используется при клике на сабмит формы.

2. _POST_ - отправка данных, создание или обновление ресурса. Данные передаются через тело запроса. Обязателен ответ от сервера - или с сохраненной записью или с ИД или новой ссылкой и т.д. _Неидемпотенттный_ **при отправке множества запросов с одними и теми же данными создаст разный эффект**, т.е. - будут другие ИД у записей в БД или создастся дубликаты и т.д. _Не кешируется, не сохраняется браузером, нет ограничений по длине тела запроса_

3. _PUT_ - создание или обновление ресурса. Отличие от POST - не требует ответа от сервера - полностью перезаписывает данные. _Идемпотентный_ - т.е. **при отправке множества идентичных запросов жедает такой же эффект - как и при отпраке одного**.

4. _PATCH_ - обновление ресурса. Отличие от PUT - **можно обновлять частично**, в зависимости от отправляемых данных. _Идемпотентный_ - задуман _как идемпотентный_, но фактическая реализация может отличаться. На практике _рекомендуется реализовывать запросы PATCH идемпотентным образом_, чтобы обеспечить согласованное поведение на сервере и в БД.

5. _DELETE_ - eудаление ресурса или данных. Тело запроса отсутствует, нужен только идентификатор ресурса.

6. _HEAD_ - идентичен GET запросу, но бех ответа со стороны сервера. Так называемый _Preflight_ запрос - т.е. используется для предзапроса, передавая информацию о предстоящем запросе. Просто возвращает метаданные о ресурсе на сервере. Возвращает все заголовки, связанные с ресурсом по заданному URL, но фактически не возвращает ресурс.
   В основном используется для проверки:

- размера ресурса на сервере;
- существует ли ресурс на сервере;
- дата последнего изменения ресурса;
- срок действия кэшированного ресурса на сервере.

7. _OPTIONS_ - метод HTTP OPTIONS возвращает список поддерживаемых и разрешенных методов, параметры и требования для конкретных ресурсов и возможностей сервера, не предпринимая никаких действий с ресурсом и не запрашивая его. В ответе в хедере Allow могут указываться разрешенные методы HTTP, в заголовках для CORS также разрешенные CORS. По соображениям безопасности, когда отправляем данные на другой домен (междоменные запросы), браузеры обычно отправляют «Preflight» запрос HTTP OPTIONS на сервер перед отправкой туда данных. Не содержит тело запроса, может иметь ответ от сервера. _Безопасный, идемпотентный_

8. _TRACE_ - используется _для диагностики, отладки и устранения неполадок_. Он просто возвращает диагностическую трассировку, в которой регистрируются данные цикла запрос-ответ.Содержимое трассировки часто представляет собой просто ответное эхо от сервера различных заголовков запросов, отправленных клиентом.

9. _CONNECT_ - запускает двустороннюю связь с запрошенным ресурсом . Его можно использовать для открытия туннеля для доступа к сайтам, использующим TLS(HTTPS). Клиент запрашивает прокси-сервер HTTP туннелировать TCP- соединение до желаемого пункта назначения. Затем прокси-сервер устанавливает соединение от имени клиента. После установления соединения прокси-сервер продолжает ретранслировать поток TCP клиенту и обратно. Пошаговый метод, не имеет тела запроса, без ответа, не кешируется, небезопасный, неидемпотентный. Иногда требует специфичных заголовков Proxy-Authorization.

A HEAD request is useful for checking what a GET request will return before actually making a GET request - a HEAD request can read the Content-Length header to check the size of the file, without actually downloading the file

</details>

##### Безопасные методы (safe)

- GET, TRACE, HEAD, OPTIONS

##### Небезопасные методы (safe)

- POST, PUT, PATCH, DELETE, CONNECT - _безопасные методы не изменяют данных на сервере_.

#### Идемпотентные методы: множество идентичных запросов дают один и тот же эффект, и при этом сервер будет в одном и том же состоянии.

- GET, PUT, DELETE, TRACE, HEAD, OPTIONS

#### Неидемпотентные методы

- PATCH, POST, CONNECT.

<details>
<summary>#### Коды ошибок от сервера</summary>

- 1xx. Информационные 100 - 199

- 2xx. Успешные 200 - 299

- 3xx. Перенаправления 300 - 399

- 4xx. Клиентские ошибки 400 - 499

- 5xx. Серверные ошибки 500 - 599

</details>

**HTTP использует 80 порт по умолчанию, HTTPS 443 порт, DNS - 53**

### HTTP vs HTTP2

<details>
<summary>- **Бинарные данные**</summary>

В HTTP данные передаются серверу в формате текста - не производительный вариант.

HTTP/2 использует бинарный формат (машинный код). Данные меньше размером, скорость передачи и парсинга выше. Браузеры с поддержкой HTTP/2 кодируют запросы в бинарный формат перед отправкой, а сервер обрабатывает запрос и декодирует.

</details>
<details>
<summary>- **Мультиплексирование**</summary>
<details>
Схема работы упрощенно сайта: GET-запрос → возвращает HTML-страницу → подключает доп ресурсы: js, css, картинки, шрифты --> сайт становится интерактивным для пользователя.

В HTTP/1.0 для загрузки каждого ресурса устанавливалось новое TCP/IP соединение. HTTP/1.1 принёс keep-alive, позволил загружать множество ресурсов в рамках одного соединения. Это значительно увеличило производительность протокола. Загрузка ресурса была последовательной (waterfall): нельзя получить следующий ресурс, пока не получен предыдущий. Т.е. зависший запрос блокирует отправку всех остальных.

В HTTP/2 вся информация бьётся на бинарные кусочки — фреймы. Они собираются в потоки - streams, для каждого запрашиваемого ресурса создаётся отдельный stream. Данные передаюся вперемешку в одном TCP/IP соединении. Принимающая сторона самостоятельно соберёт все фреймы из одного потока и обработает их. Клиент теперь может прервать получение одного потока, не закрывая соединение.

</details>
<details>
<summary>- **Сжатие заголовков через HPACK**</summary>

Раньше сжатие тела и заголовков происходило на уровне TLS. Это более низкий уровень по отношению к HTTP (микс транспортного уровня и уровня приложения). Он не знает, какой тип данных сжимает, и жмёт все через gzip.

Алгоритм сжатия был подвержен атакам типа CRIME3 и в результате злоумышленники получали авторизационные куки из сжатых заголовков. Поэтому многие сети блокировали сжатие заголовков, чтобы защитить пользователей от атак.

HTTP/2 представили новый алгоритм сжатия заголовков HPACK4. Он не использует DEFLATE и заточен под эффективную защиту от CRIME-атак. С ним новая версия HTTP стала производительнее и безопаснее.

</details>
<details>
<summary>- **Приоритизация потоков**</summary>

Управление порядком обработки и передачи потоков данных на одном соединении. Улучшает производительность, управление ресурсами эффективнее, гибкий контроль рендеринг страницы.

При отправке параллельных запросов на сервер клиент может расставить приоритеты ответов. Присваивается каждому потоку вес от 1 до 256. Чем выше вес, тем выше приоритет. Потоки могут быть связаны с ресурсами на сервере: изображениями, CSS-файлами, HTML-страницами и др.

Сервер обрабатывает данные с более высоким приоритетом, даже если это не первый поток, который был отправлен. Клиент может указывать также зависимости между потоками. Тогда сервер создаёт дерево зависимостей, которое определяет порядок получения данных.

</details>

- **Server push**

Функция, кот. позволяет серверу начать передачу ресурсов на клиент ещё до запроса.

<details>
<summary>**Как это работает:**</summary>

Клиент отправляет запрос --> GET /index.html. --> cервер определяет, что будет нужно для полной загрузки страницы. Например, CSS, JS и изображения --> сервер создаёт множество потоков данных и начинает отправлять эти ресурсы через Server Push на клиент, даже если он ещё не запросил их --> Клиент получает ресурсы и может начать их загрузку, даже если они не запрошены явно.

Server Push использует механизмы мультиплексирования и приоритизации потоков.
Но Server Push _эффективен, только если сервер точно знает, какие ресурсы нужны для загрузки страницы_. Иначе случится ненужная передача ресурсов и ухудшение производительности.

</details>
### HTTPv.3 - ключевые особенности

HTTP2 использует TCP (или TLS - for secure), HTTP3 - транспортный протокол под названием QUIC - отличается от TCP по ключевым пунктам, поэтому использовать поверх него HTTP/2 очень сложно.
Поэтому HTTP/3 — изменение HTTP/2 для адаптации к новому протоколу QUIC.
**_Расшифровка_ Quick UDP Internet Connections**

1. **TCP**
   1.1 _TCP требует рукопожатие для установки нового соеинения (handshake), для проверки, что клиент и сервер существуют и готовы обмениваться данными. Если клиент и сервер находятся далеко, время кругового пути - затраченное на отправку синрала и получения отчета о его доставке (round-trip time, RTT) может составить более 100 мс, что приводит к ощутимым задержкам._
   1.2 _TCP_ передает все, как один «файл», даже для нескольких файлов одновременно (например, загружаем страницу с несколькими ресурсами). Т.е. это задержки при передаче в случае сбоя в очереди (head-of-line (HoL) blocking).

**по факту поэтому HTTP/3 могли назвать _HTTP/2-over-QUIC_**

2. **QUIC** _находится поверх UDP протокола транспортного уровня_
   2.1 это универсальный транспортный протокол. QUIC работает поверх ещё одного протокола — UDP (_отличие от TCP в параллельной загрузке данных и из неблокировании, даже если они потерялись, удобно для видео хостингов - не важно с какого места начать передачу и т.д._). QUIC может быть и отдельным протоколом, но тогда, как и для обновления _TCP_: нудно обновить все устройства в интернете для работы с QUIC. Поэтому его разместили поверх UDP.
   2.2 использует подтверждение полученных пакетов и повторные передачи, чтобы добрать то, что потерялось - т.е. _блокирует не всю передачу данных - а только тот поток, где потерялись - потом их дошлет_.
   2.3 QUIC глубоко интегрирован с TLS - т.е. работает только с TLS, поддерживает несколько независимых потоков байтов, использует идентификаторы соединений, использует фреймы.
   **Т.е. HTTP3 по умолчанию зашифрован**
   2.4 Поддерживает миграцию соединений - т.е. соединения могут дольше оставаться активными. QUIC вводит новую концепцию — **идентификатор соединения CID**. Каждому соединению между двумя конечными точками помимо четырёх параметров (ранее в _TCP_ это были _IP-адрес клиента_ + _порт клиента_ + -IP-адрес сервера* + *порт сервера\*) присваивается уникальный номер. Поскольку **CID** определяется на транспортном уровне в самом QUIC.
   Ранее при перемещении между сетями - в TCP - перезапускалось соединение при перемещении сервера или клиента (изменении одного из 4-х указанных параметров). QUIC меняет CID при каждом переходе в новую сеть - для избежания хакерских атак. Но клиент и сервер "знают" общий список рандомно генерируемых CID, которые связаны с одним и тем же соединением - поэтому соединение не переустанавливается (сервер и клиент сверяют доступные CID).
   2.5 Гибкость и простота развития QUIC - занимает переход на него и развитие меньше времени.

3. - **Сжатие заголовков через QPACK**

4. Более быстрое установление соединения - _из-за сокращенного механизма рукопожатий_ теперь шифрование части ключа уже происходит на сервере и клиенте. За счет этого проходит сразу обмен данными, т.е. нулевое время прохождения туда и обратно (0-RTT).
5. Контроль и восстановление перегрузок

6. HTTP/3 имеет более высокую пропускную способность - из-за мультиплексирования запросов по одному соединению.

### Способы отмены запроса

##### Abort Controller - для fetch больше всего делается

- для таких целей существует специальный встроенный объект: AbortController, для отмены не только fetch, но и других асинхронных задач:

1. - создаем объект

```javascript
const controller = new AbortController();
```

Экземпляр имеет единственный метод abort() и единственное свойство signal.
_При вызове abort():_ генерируется событие с именем abort на объекте controller.signal
_свойство controller.signal.aborted становится равным true_ 2. Чтобы узнать о вызове abort(), ставим обработчики на controller.signal, чтобы отслеживать его.

```javascript
const controller = new AbortController();
const signal = controller.signal;

signal.addEventListener('abort', callback);
```

3. Вызываем метод _abort()_ - где необходимо

```javascript
const controller = new AbortController();
const signal = controller.signal;

signal.addEventListener('abort', callback);

controller.abort(); //здесь выполнится callback
```

4. Для fetch-запроса из браузерного API есть доп. опция signal? рядом с хедером и т.д.

```javascript
const controller = new AbortController();
fetch(url, {
  signal: controller.signal,
});
```

5. Вызываем событие и fetch отменится - и промис завершится с ошибкой - которую надо отловить

```javascript
controller.abort();
```

**AbortController** масштабируемый - т.е. может отменить несколько фетч запросов сразу

```javascript
const urls = ['url/1','url/2'...];

const controller = new AbortController();

const fetchList = urls.map(url => fetch(url, {
  signal: controller.signal
}));

const results = await Promise.all(fetchJobs);

// вызов controller.abort() прервёт все вызовы fetch сразу и завершит ошибкой
// обработка ошибки от вызова abort()
catch(err) {
  if (err.name == 'AbortError') {
    errorCallback();
  } else {
    throw err;
  }
}
```

**соответственно, если надо управлять гибко отменой - надо создать несколько объектов abortController**

##### `abort()` в объекте запроса - для старого XMLHttpRequest.

##### Промисы и async/await:

При использовании промисов или async/await, можно использовать Promise.race, чтобы создать гонку между промисом запроса и промисом отмены. Как только промис отмены выполнится первым, вы сможете обработать отмену запроса.

```javascript

```

##### Использование Axios (или других HTTP клиентов):

- Некоторые HTTP клиенты, такие как Axios, предоставляют встроенные методы для отмены запросов.

```javascript
import axios from 'axios';

const cancelTokenController = axios.CancelToken.source();

axios
  .get('https://api.example.com/data', { cancelToken: cancelTokenController.token })
  .then((response) => {
    console.log(response.data);
  })
  .catch((error) => {
    if (axios.isCancel(error)) {
      console.log('Request cancelled:', error.message);
    } else {
      console.log('Error:', error.message);
    }
  });

cancelTokenController.cancel('Request cancelled manually'); //cancel event
```

### Объекты в JS

<details>
<summary>Методы объектов</summary>

- **Создание объектов**

```javascript
const obj = {}; // литеральная запись - прямое создание
const obj2 = new Obj(); // с помощью конструктора
/*
Несмотря на то, что obj и obj2 неизменные, свойства объекта можно менять, т.к. объект хранится по ссылке. Изменение внутреннего состояния не изменяет ссылку.
Но нельзя перезаписать объект obj2='other type' //TypeError: Assignment to constant variable
*/
function FuncConstructor(prop1, prop2) {
  //функция-конструктор
  this.key1 = prop1;
  this.key2 = prop2;
}
/* is the same as implicitly {
	const this={};
	{body function}
	return this;
}*/
// обязательно вызывать только с new - если вызвать без new - просто вернет undefined;
class ObjCreator {
  constructor(prop1, prop2) {
    this.key1 = prop1;
    this.key2 = prop2;
  }
  //come methods
  sayHi() {
    return `Hi user ${this.key1}`;
  }
}
//современный синтаксис - класс вместо функции конструктора
// в данном случае вернет при вызове без new - TypeError - нельзя вызывать класс без new!!!

//Использование метода Object.create
const newObj = Object.create(prototype, props); //мы можем передать прототип - т.е. тот объект, от которого наследуемся - и таким образом мы получим доступ к его свойствам
//props - это обязательно объект с ключами и значениями

const newObj = Object.create({}, { user: 'user' }); //к пустому объекту добавим св-во user

//можно добавлять дескрипторы свойств
const newObj = Object.create({}, { name: { value: 'user', enumarable: false, writable: true, configurable: false } });
//или включать геттеры и сеттеры
const newObj = Object.create(
  {},
  {
    name: {
      value: '',
      enumarable: false,
      writable: true,
      configurable: false,
      get: function () {},
      set: function () {},
    },
  }
);

//через Object.defineProperty(); || Object.defineProperties();
const obj1=Object.defineProperty({}, 'user', {get:, set:, descriptors: writanle,enumarable,configurable});
```

- удаление свойств: - удаляет свойство объекта - при образении к такому св-ву вернется undefined - как и у любошо несуществующего св-ва

- более структурно см. (Дескрипторы на learnJS)[https://learn.javascript.ru/descriptors-getters-setters]

```javascript
delete object.someProperty;
delete object['property'];
```

- новый синтаксис объявления свойств (_касаемо методов_):

```javascript
const obj = {
  name: 'defaultName',
  sayHi: function () {
    console.log('hi');
  },
}; // old
const objNew = {
  name: 'defaultName',
  sayHi() {
    console.log('hi');
  },
}; //new
//when we have variables
const name = 'name';
const lastName = 'lastName';
const objShort = {
  name,
  lastName,
};
//the same as {name: name, lastName:lastName};
```

- обращение к св-ву объекта через `. obj.prop` или через квадратные скобки - удобно для переменных или составных свойств (типа класса в ДОМ узлах) `obj[property] или obj['complete__className-prop']`

- _ограничения_ - ключи - только строки или символы, значения - любой тип данных;

</details>

<details>
<summary>Копирование объектов в JS</summary>

</details>

#### Функция structuredClone()

<details>
<summary>Глубокое копирование объектов в JS</summary>

`structuredClone` является встроенным методом, который позволяет создавать глубокую копию объекта или сложной структуры данных - т.е. объекта window или global nodeJS. Предоставляется `Web API` в современных браузерах. Рекурсивно клонирует свойства и вложенные объекты.

**Пример**

```javascript
const originalObject = {
  name: 'John',
  age: 30,
  addresses: [{ street: '123 Main St', city: 'New York' }],
};

const clonedObject = window.structuredClone(originalObject) || structuredClone(originalObject);
```

**Ограничения**

- Функции и методы не клонируются;

- некоторые свойства, как символы или свойства с круговыми ссылками, не могут быть сериализованы и исключаются во время процесса клонирования. Полученная копия не будет содержать эти свойства.

- Узлы DOM и сложные встроенные объекты: File или Blob.

Для большей инфорации см. (Доку от MDN)[https://developer.mozilla.org/en-US/docs/Web/API/structuredClone]

</details>
